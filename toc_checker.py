from docx import Document
from docx.oxml.ns import qn
import zipfile
from lxml import etree
import re

class TocChecker:
    def __init__(self):
        # 扩展目录样式列表，增加更多可能的中文目录样式名称
        self.toc_styles = ['TOC 1', 'TOC 2', 'TOC 3', '目录 1', '目录 2', '目录 3', '标题 1', '标题 2', '标题 3', 'toc 1', 'toc 2', 'toc 3']
        self.number_pattern = re.compile(r'^\d+\.')
        self.level_patterns = {
            1: re.compile(r'^\d+\.'),
            2: re.compile(r'^\d+\.\d+\.'),
            3: re.compile(r'^\d+\.\d+\.\d+\.')
        }

    def debug_document_styles(self, docx_path, start=0, end=50):
        """
        调试函数：输出文档指定范围内段落的样式名称和文本
        """
        doc = Document(docx_path)
        print(f"文档第{start+1}至{end}段的样式和内容:")
        for i, para in enumerate(doc.paragraphs[start:end]):
            actual_index = start + i + 1
            text = para.text.strip()
            print(f"段落 {actual_index}: {para.style.name} - {text[:50]}{'...' if len(text) > 50 else ''}")
        return

    def debug_toc_styles(self, docx_path):
        """
        专门用于调试目录样式的函数
        """
        doc = Document(docx_path)
        print("===== 目录样式调试信息 =====")
        
        # 检查包含"目录"的段落
        toc_start = -1
        for i, para in enumerate(doc.paragraphs):
            if '目录' in para.text.strip() and len(para.text.strip()) < 10:
                toc_start = i
                print(f"找到'目录'标题在段落 {i+1}: {para.style.name} - {para.text.strip()}")
                break

        # 如果找到目录标题，查看其后的30个段落
        if toc_start >= 0:
            print("\n目录标题后的段落:")
            for i in range(toc_start, min(toc_start + 30, len(doc.paragraphs))):
                para = doc.paragraphs[i]
                text = para.text.strip()
                print(f"段落 {i+1}: {para.style.name} - {text}")
        else:
            print("未找到明显的'目录'标题段落")

        # 检查是否有toc样式的段落
        print("\n包含toc样式的段落:")
        toc_paras_found = False
        for i, para in enumerate(doc.paragraphs):
            if para.style.name.startswith('toc'):
                toc_paras_found = True
                text = para.text.strip()
                print(f"段落 {i+1}: {para.style.name} - {text}")
        if not toc_paras_found:
            print("未找到使用toc样式的段落")

        # 检查是否有目录相关的样式
        print("\n文档中使用的所有样式:")
        styles_used = set()
        for para in doc.paragraphs:
            styles_used.add(para.style.name)
        print(sorted(styles_used))
        
        print("==========================")
        return

    def improved_is_toc_autogenerated(self, docx_path):
        """
        改进的目录自动生成检测方法
        """
        # 方法1: 检查是否包含 TOC 字段
        has_toc_field = False
        try:
            with zipfile.ZipFile(docx_path) as docx_zip:
                if 'word/document.xml' in docx_zip.namelist():
                    with docx_zip.open('word/document.xml') as doc_xml:
                        xml_content = doc_xml.read().decode('utf-8')
                        if 'w:fldCharType="begin"' in xml_content and 'TOC' in xml_content:
                            has_toc_field = True
        except Exception as e:
            print(f"检查TOC字段时出错: {e}")

        # 方法2: 检查是否使用了目录样式
        has_toc_style = False
        doc = Document(docx_path)
        # 检查前200个段落，因为目录可能在文档中间
        for para in doc.paragraphs[:200]:
            if para.style.name in self.toc_styles:
                has_toc_style = True
                break
            # 额外检查: 段落文本是否包含典型的目录项格式
            text = para.text.strip()
            if re.match(r'^\d+\.\s+[\w\W]+\s+\d+$', text):  # 例如: "1. 引言 1"
                has_toc_style = True
                break
            # 检查是否包含"目录"标题
            if '目录' in text and len(text) < 10:
                has_toc_style = True
                break

        return has_toc_field or has_toc_style

    def is_toc_autogenerated(self, docx_path):
        """
        检查目录是否自动生成
        通过检测文档中的 TOC 字段和特殊样式来判断
        """
        return self.improved_is_toc_autogenerated(docx_path)

    def check_toc_levels(self, docx_path):
        """
        检查目录层级和格式
        返回目录项列表和可能的问题
        """
        doc = Document(docx_path)
        toc_items = []
        issues = []
        prev_level = 0
        prev_number = []
        special_items = ['摘要', 'ABSTRACT', '参考文献', '致谢', '目  录']

        for i, para in enumerate(doc.paragraphs):
            if para.style.name in self.toc_styles:
                text = para.text.strip()
                if not text:  # 跳过空段落
                    continue

                # 处理特殊目录项（摘要、ABSTRACT等）
                is_special = False
                for item in special_items:
                    # 宽松匹配，只要文本中包含特殊项关键词即可
                    if item in text:
                        is_special = True
                        toc_items.append({
                            "level": 1, "number": '', "title": text, 
                            "paragraph_index": i, "is_special": True
                        })
                        break

                if is_special:
                    continue

                # 处理带罗马数字的摘要项（如"摘  要   I"）
                roman_match = re.match(r'^[\u4e00-\u9fa5\s]+[IVXLCDM]+\s*$', text)
                if roman_match:
                    toc_items.append({
                        "level": 1, "number": '', "title": text, 
                        "paragraph_index": i, "is_special": True
                    })
                    continue

                if is_special:
                    continue

                # 提取标题编号和文本
                number_match = re.match(r'(^[\d\.]+)\s+(.*)', text)
                if number_match:
                    number = number_match.group(1)
                    title = number_match.group(2)
                    # 确定级别
                    level = number.count('.') + 1
                    if level > 3:
                        issues.append(f"目录项级别超过3级: {text}")
                    # 检查编号连续性
                    number_parts = list(map(int, number.split('.')))
                    if level > prev_level:
                        if len(number_parts) != level or number_parts[-1] != 1:
                            issues.append(f"子标题应从1开始: {text}")
                    elif level == prev_level:
                        if len(number_parts) != level or number_parts[-1] != prev_number[-1] + 1:
                            issues.append(f"标题编号不连续: {text}")
                    else:
                        if len(number_parts) != level or number_parts[-1] != prev_number[level-1] + 1:
                            issues.append(f"标题编号不连续: {text}")
                    prev_level = level
                    prev_number = number_parts
                    toc_items.append({
                        "level": level, "number": number, "title": title, 
                        "paragraph_index": i
                    })
                else:
                    # 检查是否是章节标题（如"第1章 绪 论"或"第五章 总结"）
                    chapter_match = re.match(r'^第[一二三四五六七八九十]+章\s+', text) or re.match(r'^第\d+章\s+', text)
                    if chapter_match:
                        # 提取章节号
                        chapter_number = re.search(r'[一二三四五六七八九十\d]+', chapter_match.group()).group()
                        title = text[chapter_match.end():].strip()

                        # 检查章节编号连续性
                        # 转换中文数字为阿拉伯数字
                        chinese_to_arabic = {'一':1, '二':2, '三':3, '四':4, '五':5, '六':6, '七':7, '八':8, '九':9, '十':10}
                        if chapter_number in chinese_to_arabic:
                            current_number = [chinese_to_arabic[chapter_number]]
                        else:
                            current_number = [int(chapter_number)]

                        if len(prev_number) >= 1:
                            expected_number = [prev_number[0] + 1]
                            if current_number != expected_number:
                                issues.append(f"章节编号不连续: {text}")

                        prev_level = 1
                        prev_number = current_number

                        toc_items.append({
                            "level": 1, "number": chapter_number, "title": title, 
                            "paragraph_index": i, "is_chapter": True
                        })
                    else:
                        issues.append(f"目录项格式不正确(缺少编号): {text}")
                        toc_items.append({
                            "level": 1, "number": '', "title": text, 
                            "paragraph_index": i
                        })

        return toc_items, issues

    def check_toc_format(self, docx_path):
        """
        综合检查目录格式
        """
        result = {
            "is_autogenerated": False,
            "toc_items": [],
            "issues": [],
            "summary": ""
        }

        # 检查是否自动生成
        result["is_autogenerated"] = self.is_toc_autogenerated(docx_path)

        # 检查层级和格式
        result["toc_items"], result["issues"] = self.check_toc_levels(docx_path)

        # 生成摘要
        if not result["is_autogenerated"]:
            result["summary"] = "❌ 目录不是自动生成的"
        else:
            if not result["issues"]:
                result["summary"] = f"✅ 目录格式正确，共{len(result['toc_items'])}项"
            else:
                result["summary"] = f"⚠️ 目录存在{len(result['issues'])}个问题"

        return result

    def generate_report(self, docx_path, report_path=None):
        """
        生成目录检测报告
        """
        result = self.check_toc_format(docx_path)

        report = ["# 目录格式检测报告", ""]
        report.append(f"## 基本信息")
        report.append(f"- 文档路径: {docx_path}")
        report.append(f"- 是否自动生成: {'是' if result['is_autogenerated'] else '否'}")
        report.append(f"- 目录项数量: {len(result['toc_items'])}")
        report.append(f"- 问题数量: {len(result['issues'])}")
        report.append("")

        if result['issues']:
            report.append("## 问题列表")
            for i, issue in enumerate(result['issues'], 1):
                report.append(f"{i}. {issue}")
            report.append("")

        if result['toc_items']:
            report.append("## 目录结构")
            for item in result['toc_items']:
                if item.get('is_special'):
                    report.append(f"- {item['title']}")
                elif item.get('is_chapter'):
                    report.append(f"- 第{item['number']}章 {item['title']}")
                else:
                    indent = "  " * (item['level'] - 1)
                    report.append(f"{indent}- {item['number']} {item['title']}")
            report.append("")

        report.append(f"## 结论")
        report.append(result['summary'])

        report_text = "\n".join(report)

        if report_path:
            with open(report_path, 'w', encoding='utf-8') as f:
                f.write(report_text)
            print(f"报告已保存至: {report_path}")

        return report_text


def main():
        docx_path = "ThesisCheck\\测试论文.docx"
        checker = TocChecker()
        
        # 专门调试目录样式
        checker.debug_toc_styles(docx_path)
        
        report = checker.generate_report(docx_path, "ThesisCheck\\toc_report.md")
        print(report)


if __name__ == "__main__":
    main()